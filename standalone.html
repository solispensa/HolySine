<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/png" href="./favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>HolySine Tuner</title>
    <style>
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap');

:root {
    --bg-color: #050508;
    --surface-color: rgba(255, 255, 255, 0.03);
    --border-color: rgba(255, 255, 255, 0.08);
    --accent-primary: #00f2ff;
    --accent-secondary: #7000ff;
    --text-primary: #ffffff;
    --text-secondary: #a0a0b0;
    --success: #00ff88;
    --warning: #ffaa00;
    --error: #ff4466;
    --glass-blur: 16px;
}

* {
    box-sizing: border-box;
    -webkit-font-smoothing: antialiased;
}

body {
    margin: 0;
    padding: 0;
    background-color: var(--bg-color);
    background-image:
        radial-gradient(circle at 20% 30%, rgba(112, 0, 255, 0.05) 0%, transparent 40%),
        radial-gradient(circle at 80% 70%, rgba(0, 242, 255, 0.05) 0%, transparent 40%);
    color: var(--text-primary);
    font-family: 'Inter', system-ui, sans-serif;
    overflow-x: hidden;
    min-height: 100vh;
}

#app {
    display: flex;
    flex-direction: column;
    min-height: 100vh;
    padding: 0;
    max-width: none;
    margin: 0;
}

main {
    flex: 1;
    padding: 2rem;
    padding-bottom: 5rem;
    display: flex;
    flex-direction: column;
    align-items: center;
}

.view {
    display: none;
    width: 100%;
    max-width: 1000px;
    animation: fadeIn 0.4s ease-out;
}

.view.active {
    display: block;
}

.monitor-title {
    color: var(--text-secondary);
    font-size: 0.9rem;
    margin-bottom: 2rem;
    font-weight: 300;
}

/* Tuning Card Styles */
.tuning-card {
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.05) 0%, rgba(255, 255, 255, 0.02) 100%);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border: 1px solid var(--border-color);
    border-radius: 20px;
    padding: 1.5rem;
    position: relative;
    overflow: hidden;
    margin-bottom: 1rem;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    transition: border-color 0.3s ease;
}

.tuning-card.in-tune {
    border-color: rgba(0, 255, 136, 0.3);
}

.card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
    position: relative;
    z-index: 2;
}

#simple-view .card-header {
    flex-direction: column;
    justify-content: center;
}

.string-info {
    font-size: 1.5rem;
    font-weight: 600;
    color: var(--text-primary);
}

#simple-view .string-info {
    font-size: 2.2rem;
    text-align: center;
}

.measurement-info {
    text-align: right;
}

.cents-display {
    font-size: 2.2rem;
    font-weight: 700;
    display: block;
    line-height: 1;
}

.cents-label {
    font-size: 0.7rem;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: var(--text-secondary);
}

.freq-display {
    font-size: 0.9rem;
    color: var(--text-secondary);
    font-family: monospace;
    margin-top: 0.5rem;
    display: block;
}

.scale-container {
    position: relative;
    height: 45vh;
    /* Vertical orientation needs height for history */
    min-height: 250px;
    margin: 1rem 0;
    display: flex;
    gap: 1rem;
    background: linear-gradient(to right,
            transparent 0%,
            transparent 49.5%,
            rgba(0, 255, 136, 0.4) 49.5%,
            rgba(0, 255, 136, 0.4) 50.5%,
            transparent 50.5%,
            transparent 100%);
    border-radius: 12px;
    border: 1px solid rgba(255, 255, 255, 0.03);
    padding-top: 1.5rem;
    /* space for horizontal markers at top */
}

.scale-markers {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 1.5rem;
    width: 100%;
    color: var(--text-secondary);
    font-size: 0.7rem;
    font-family: monospace;
    padding: 0;
    line-height: 1;
}

.scale-markers span {
    position: absolute;
    transform: translateX(-50%);
    top: 0.2rem;
}

.scale-markers span:nth-child(1) {
    left: 10%;
}

/* -50 */
.scale-markers span:nth-child(2) {
    left: 26%;
}

/* -30 */
.scale-markers span:nth-child(3) {
    left: 34%;
}

/* -20 */
.scale-markers span:nth-child(4) {
    left: 42%;
}

/* -10 */
.scale-markers span:nth-child(5) {
    left: 50%;
}

/* 0 */
.scale-markers span:nth-child(6) {
    left: 58%;
}

/* +10 */
.scale-markers span:nth-child(7) {
    left: 66%;
}

/* +20 */
.scale-markers span:nth-child(8) {
    left: 74%;
}

/* +30 */
.scale-markers span:nth-child(9) {
    left: 90%;
}

/* +50 */

.scale-line {
    position: absolute;
    top: 1.5rem;
    left: 50%;
    transform: translateX(-50%);
    height: calc(100% - 1.5rem);
    width: 1px;
    background: rgba(255, 255, 255, 0.15);
    z-index: 1;
}

.oscilloscope-canvas {
    position: relative;
    width: 100%;
    height: 100%;
    z-index: 2;
    opacity: 0.9;
}

/* Bottom Nav Styles */
.bottom-nav {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    background: rgba(10, 10, 15, 0.9);
    backdrop-filter: blur(10px);
    display: flex;
    justify-content: space-around;
    padding: 1rem;
    border-top: 1px solid var(--border-color);
    z-index: 100;
}

.nav-item {
    background: none;
    border: none;
    color: var(--text-secondary);
    padding: 0.5rem 1rem;
    font-size: 0.9rem;
    cursor: pointer;
    transition: color 0.3s ease;
    position: relative;
}

.nav-item.active {
    color: var(--text-primary);
}

.nav-item.active::after {
    content: '';
    position: absolute;
    bottom: -5px;
    left: 50%;
    transform: translateX(-50%);
    width: 20px;
    height: 3px;
    background: var(--accent-primary);
    border-radius: 2px;
}

/* Initial Overlay */
#initial-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: var(--bg-color);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 200;
}

.poly-grid {
    display: flex;
    flex-direction: row;
    /* 6 vertical columns side-by-side */
    justify-content: stretch;
    gap: 0.2rem;
    width: 100%;
    height: 100%;
    align-items: stretch;
}

/* Compact styles for Poly Tuner cards to fit on screen */
#poly-view {
    height: calc(100vh - 220px);
    max-height: 800px;
    flex-direction: column;
}

#poly-view.active {
    display: flex;
}

#poly-view .tuning-card {
    flex: 1;
    padding: 0.2rem;
    margin-bottom: 0;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    max-width: none;
    border-radius: 8px;
}

#poly-view .card-header {
    position: static;
    /* Let measurement-info be relative to tuning-card */
    margin-bottom: 0.2rem;
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
}

#poly-view .string-info {
    font-size: 0.8rem;
    white-space: nowrap;
}

#poly-view .measurement-info {
    position: absolute;
    bottom: 1rem;
    left: 50%;
    transform: translateX(-50%);
    height: auto;
    width: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    z-index: 10;
    pointer-events: none;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 1), 0 0 10px rgba(0, 0, 0, 0.8);
}

#poly-view .cents-display {
    font-size: 1rem;
}

#poly-view .cents-label {
    display: none;
    /* Hide 'Cents' label to save space on narrow columns */
}

#poly-view .freq-display {
    font-size: 0.6rem;
    margin-top: 0;
}

#poly-view .scale-container {
    flex: 1;
    /* Fill the remaining vertical space */
    width: 100%;
    margin: 0;
    padding: 0;
    /* Remove top padding to save vertical space */
    height: auto;
}

#poly-view .scale-line {
    top: 0;
    /* No top marker space */
    height: 100%;
}

#poly-view .scale-markers {
    top: 5px;
    left: 0;
    width: 100%;
    height: auto;
}

#poly-view .scale-markers span {
    font-size: 0.55rem;
}

#poly-view .scale-markers span:not(:nth-child(5)) {
    display: none;
    /* Only show the '0' marker in Poly view to save horizontal space */
}

.btn-primary:hover {
    transform: scale(1.05);
    box-shadow: 0 15px 30px -5px rgba(0, 242, 255, 0.4);
}

.btn-primary:active {
    transform: scale(0.98);
}

@keyframes fadeIn {
    from {
        opacity: 0;
        transform: translateY(10px);
    }

    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.status-message {
    color: var(--text-secondary);
    font-size: 0.9rem;
    font-style: italic;
    animation: pulse 2s infinite ease-in-out;
}

@keyframes pulse {

    0%,
    100% {
        opacity: 0.5;
    }

    50% {
        opacity: 1;
    }
}

@media (max-width: 640px) {
    header h1 {
        font-size: 2.5rem;
    }

    .tuner-card {
        padding: 1.5rem;
    }
}

/* Settings Page Styles */
.config-content {
    padding: 1rem;
    max-width: 600px;
    margin: 0 auto;
}

.config-title {
    font-size: 1.8rem;
    font-weight: 700;
    color: #00ff88;
    text-transform: none;
    letter-spacing: normal;
    text-align: left;
    margin-bottom: 2rem;
    padding-left: 1rem;
}

.settings-group {
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.setting-option {
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: rgba(255, 255, 255, 0.03);
    border: 1px solid rgba(255, 255, 255, 0.05);
    border-radius: 12px;
    padding: 1rem 1.5rem;
    cursor: pointer;
    transition: all 0.2s ease;
}

.setting-option:hover {
    background: rgba(255, 255, 255, 0.05);
}

.setting-option input[type="radio"] {
    display: none;
}

.setting-details {
    display: flex;
    flex-direction: column;
    gap: 0.2rem;
}

.setting-name {
    font-weight: 600;
    color: var(--text-primary);
    font-size: 1.1rem;
}

.setting-desc {
    font-family: monospace;
    color: var(--text-secondary);
    font-size: 0.85rem;
    letter-spacing: 2px;
}

.radio-indicator {
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.empty-circle {
    width: 18px;
    height: 18px;
    border: 2px solid var(--text-secondary);
    border-radius: 50%;
    opacity: 0.5;
}

.check-icon {
    width: 24px;
    height: 24px;
    display: none;
}

.setting-option input[type="radio"]:checked~.radio-indicator .empty-circle {
    display: none;
}

.setting-option input[type="radio"]:checked~.radio-indicator .check-icon {
    display: block;
}

.setting-option:has(input[type="radio"]:checked) {
    border-color: rgba(0, 255, 136, 0.2);
    background: rgba(0, 255, 136, 0.02);
}

.settings-divider {
    color: var(--text-secondary);
    font-size: 0.8rem;
    font-weight: 600;
    letter-spacing: 2px;
    margin: 2rem 0 1rem;
    text-transform: uppercase;
}

.calibration-group {
    background: rgba(255, 255, 255, 0.03);
    border: 1px solid rgba(255, 255, 255, 0.05);
    border-radius: 12px;
    padding: 1.5rem;
}

.calibration-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1.5rem;
}

.calibration-title {
    font-weight: 500;
}

.calibration-val {
    color: #00ff88;
    font-weight: bold;
    font-family: monospace;
    font-size: 1.1rem;
}

/* Custom Range Slider */
input[type=range] {
    -webkit-appearance: none;
    width: 100%;
    height: 6px;
    border-radius: 3px;
    background: rgba(255, 255, 255, 0.1);
}

input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    height: 18px;
    width: 18px;
    border-radius: 50%;
    background: #00ff88;
    cursor: pointer;
    margin-top: -6px;
    box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
}

input[type=range]::-webkit-slider-runnable-track {
    width: 100%;
    height: 6px;
    cursor: pointer;
    background: transparent;
    border-radius: 3px;
}

/* Analyzer Overlay */
#analyzer-canvas {
    position: fixed;
    bottom: 0px;
    left: 0;
    width: 100vw;
    height: 100vh;
    /* Adjust height to not cover top elements if needed, but opacity helps */
    z-index: 1;
    /* Behind main z-index 2 */
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.5s ease;
}

#analyzer-canvas.active {
    opacity: 0.6;
    /* Stronger background glow effect */
}

/* Toggle Button */
.toggle-btn {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 100;
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid var(--border-color);
    border-radius: 20px;
    padding: 0.5rem 1rem;
    color: var(--text-secondary);
    display: flex;
    align-items: center;
    gap: 0.5rem;
    cursor: pointer;
    backdrop-filter: blur(10px);
    transition: all 0.3s ease;
    font-size: 0.8rem;
    font-weight: 600;
}

.toggle-btn:hover {
    background: rgba(255, 255, 255, 0.1);
}

.toggle-btn.active {
    background: rgba(0, 242, 255, 0.1);
    color: var(--accent-primary);
    border-color: rgba(0, 242, 255, 0.3);
}

.eq-icon {
    width: 16px;
    height: 16px;
}
</style>
</head>

<body>
    <!-- Frequency Analyzer Canvas -->
    <canvas id="analyzer-canvas"></canvas>

    <!-- Analyzer Toggle Button -->
    <button id="analyzer-toggle-btn" class="toggle-btn">
        <svg viewBox="0 0 24 24" class="eq-icon">
            <path d="M4 14v-4m4 8v-12m4 16v-20m4 16v-8m4 12v-16" stroke="currentColor" stroke-width="2"
                stroke-linecap="round" />
        </svg>
        <span>Spectrogram</span>
    </button>

    <div id="app">
        <main style="position: relative; z-index: 2;">
            <!-- Simple Tuner View -->
            <section id="simple-view" class="view active">
                <div id="simple-tuner-container"></div>
            </section>

            <!-- Poly Tuner View -->
            <section id="poly-view" class="view">
                <div id="poly-tuner-grid" class="poly-grid"></div>
            </section>

            <!-- Configurations View -->
            <section id="config-view" class="view">
                <div class="monitor-title config-title">Tuner Settings</div>
                <div class="config-content">

                    <div class="settings-group">
                        <label class="setting-option">
                            <input type="radio" name="tuning" value="standard" checked>
                            <div class="setting-details">
                                <span class="setting-name">Standard Tuning</span>
                                <span class="setting-desc">E A D G B E</span>
                            </div>
                            <div class="radio-indicator">
                                <svg viewBox="0 0 24 24" class="check-icon">
                                    <circle cx="12" cy="12" r="10" fill="#00ff88" />
                                    <path d="M7 13l3 3 7-7" stroke="#101015" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" fill="none" />
                                </svg>
                                <div class="empty-circle"></div>
                            </div>
                        </label>

                        <label class="setting-option">
                            <input type="radio" name="tuning" value="drop_d">
                            <div class="setting-details">
                                <span class="setting-name">Drop D</span>
                                <span class="setting-desc">D A D G B E</span>
                            </div>
                            <div class="radio-indicator">
                                <svg viewBox="0 0 24 24" class="check-icon">
                                    <circle cx="12" cy="12" r="10" fill="#00ff88" />
                                    <path d="M7 13l3 3 7-7" stroke="#101015" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" fill="none" />
                                </svg>
                                <div class="empty-circle"></div>
                            </div>
                        </label>

                        <label class="setting-option">
                            <input type="radio" name="tuning" value="open_g">
                            <div class="setting-details">
                                <span class="setting-name">Open G</span>
                                <span class="setting-desc">D G D G B D</span>
                            </div>
                            <div class="radio-indicator">
                                <svg viewBox="0 0 24 24" class="check-icon">
                                    <circle cx="12" cy="12" r="10" fill="#00ff88" />
                                    <path d="M7 13l3 3 7-7" stroke="#101015" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" fill="none" />
                                </svg>
                                <div class="empty-circle"></div>
                            </div>
                        </label>

                        <label class="setting-option">
                            <input type="radio" name="tuning" value="eb_standard">
                            <div class="setting-details">
                                <span class="setting-name">Eb Standard</span>
                                <span class="setting-desc">Eb Ab Db Gb Bb Eb</span>
                            </div>
                            <div class="radio-indicator">
                                <svg viewBox="0 0 24 24" class="check-icon">
                                    <circle cx="12" cy="12" r="10" fill="#00ff88" />
                                    <path d="M7 13l3 3 7-7" stroke="#101015" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" fill="none" />
                                </svg>
                                <div class="empty-circle"></div>
                            </div>
                        </label>

                        <label class="setting-option">
                            <input type="radio" name="tuning" value="open_esus2">
                            <div class="setting-details">
                                <span class="setting-name">Open Esus2</span>
                                <span class="setting-desc">E B E F# B E</span>
                            </div>
                            <div class="radio-indicator">
                                <svg viewBox="0 0 24 24" class="check-icon">
                                    <circle cx="12" cy="12" r="10" fill="#00ff88" />
                                    <path d="M7 13l3 3 7-7" stroke="#101015" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" fill="none" />
                                </svg>
                                <div class="empty-circle"></div>
                            </div>
                        </label>

                        <label class="setting-option">
                            <input type="radio" name="tuning" value="dadgad">
                            <div class="setting-details">
                                <span class="setting-name">DADGAD</span>
                                <span class="setting-desc">D A D G A D</span>
                            </div>
                            <div class="radio-indicator">
                                <svg viewBox="0 0 24 24" class="check-icon">
                                    <circle cx="12" cy="12" r="10" fill="#00ff88" />
                                    <path d="M7 13l3 3 7-7" stroke="#101015" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" fill="none" />
                                </svg>
                                <div class="empty-circle"></div>
                            </div>
                        </label>

                        <label class="setting-option">
                            <input type="radio" name="tuning" value="rain_song">
                            <div class="setting-details">
                                <span class="setting-name">Rain Song</span>
                                <span class="setting-desc">D G C G C D</span>
                            </div>
                            <div class="radio-indicator">
                                <svg viewBox="0 0 24 24" class="check-icon">
                                    <circle cx="12" cy="12" r="10" fill="#00ff88" />
                                    <path d="M7 13l3 3 7-7" stroke="#101015" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" fill="none" />
                                </svg>
                                <div class="empty-circle"></div>
                            </div>
                        </label>

                        <label class="setting-option">
                            <input type="radio" name="tuning" value="custom">
                            <div class="setting-details">
                                <span class="setting-name">Custom</span>
                                <span class="setting-desc">Enter notes manually</span>
                            </div>
                            <div class="radio-indicator">
                                <svg viewBox="0 0 24 24" class="check-icon">
                                    <circle cx="12" cy="12" r="10" fill="#00ff88" />
                                    <path d="M7 13l3 3 7-7" stroke="#101015" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" fill="none" />
                                </svg>
                                <div class="empty-circle"></div>
                            </div>
                        </label>

                        <div id="custom-tuning-input"
                            style="display: none; flex-direction: column; gap: 0.5rem; margin-top: 0.5rem; padding: 1rem; background: rgba(0,0,0,0.2); border-radius: 8px;">
                            <label
                                style="font-size: 0.8rem; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 1px;">Scientific
                                Pitch Notation (comma separated):</label>
                            <input type="text" id="custom-tuning-text" value="E4, B3, G3, D3, A2, E2"
                                style="background: transparent; border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; color: #fff; padding: 0.5rem; font-family: monospace; outline: none;">
                            <button id="apply-custom-tuning"
                                style="background: #00ff88; color: #000; border: none; padding: 0.5rem; border-radius: 4px; font-weight: bold; cursor: pointer;">Apply
                                Tuning</button>
                        </div>
                    </div>

                    <div class="settings-divider">CALIBRATION</div>

                    <div class="calibration-group">
                        <div class="calibration-header">
                            <span class="calibration-title">Reference Pitch</span>
                            <span id="pitch-val" class="calibration-val">440 Hz</span>
                        </div>
                        <input type="range" id="pitch-slider" min="430" max="450" value="440" step="1">
                    </div>

                </div>
            </section>
        </main>

        <!-- Bottom Navigation -->
        <nav class="bottom-nav">
            <button class="nav-item active" data-view="simple-view">Simple Tuner</button>
            <button class="nav-item" data-view="poly-view">Poly Tuner</button>
            <button class="nav-item" data-view="config-view">Configurations</button>
        </nav>

        <div id="initial-overlay">
            <button id="start-audio" class="btn-primary">Initialize Engine</button>
        </div>
    </div>
    <script>
class AudioProcessor {
    constructor() {
        this.audioContext = null;
        this.analyser = null;
        this.microphone = null;
        this.dataArray = null;
        this.isInitialized = false;
        this.onUpdate = null;
    }

    async initialize() {
        if (this.isInitialized) return;

        try {
            // Disable browser audio processing for raw signal
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const stream = await navigator.mediaDevices.getUserMedia({
                audio: {
                    echoCancellation: false,
                    noiseSuppression: false,
                    autoGainControl: false
                }
            });

            this.microphone = this.audioContext.createMediaStreamSource(stream);
            this.analyser = this.audioContext.createAnalyser();
            this.analyser.fftSize = 8192; // High resolution required for Poly Tuner separation

            this.microphone.connect(this.analyser);
            this.dataArray = new Float32Array(this.analyser.fftSize);

            this.isInitialized = true;
            this.startProcessing();
            return true;
        } catch (err) {
            console.error('Error accessing microphone:', err);
            return false;
        }
    }

    startProcessing() {
        const process = () => {
            if (!this.isInitialized) return;
            // Capture time-domain data for autocorrelation
            this.analyser.getFloatTimeDomainData(this.dataArray);
            requestAnimationFrame(process);
        };
        process();
    }

    // High-precision Autocorrelation for pitch detection using SDF (Square Difference Function)
    static autoCorrelate(buffer, sampleRate) {
        let SIZE = buffer.length;
        let rms = 0;

        for (let i = 0; i < SIZE; i++) {
            rms += buffer[i] * buffer[i];
        }
        rms = Math.sqrt(rms / SIZE);

        // Signal too weak or silence
        if (rms < 0.002) return -1;

        // Perform Square Difference Function within musical frequency range (40Hz to 1200Hz)
        const minLag = Math.floor(sampleRate / 1200);
        const maxLag = Math.floor(sampleRate / 40);

        // We use a half-size window to ensure we have enough data for the lag
        const windowSize = Math.floor(SIZE / 2);
        const diff = new Float32Array(maxLag + 1);

        for (let lag = minLag; lag <= maxLag; lag++) {
            for (let i = 0; i < windowSize; i++) {
                const delta = buffer[i] - buffer[i + lag];
                diff[lag] += delta * delta;
            }
        }

        // Find the first significant "valley" to avoid octave errors
        let bestLag = -1;
        let minDiff = Infinity;
        let threshold = 0.2 * diff[minLag]; // Dynamic threshold for first valley

        for (let lag = minLag; lag <= maxLag; lag++) {
            if (diff[lag] < minDiff) {
                minDiff = diff[lag];
                bestLag = lag;
            }
            // If we found a significant local minimum, stop to avoid harmonics/octave errors
            if (lag > minLag && diff[lag] < threshold && diff[lag] < diff[lag - 1] && diff[lag] < diff[lag + 1]) {
                bestLag = lag;
                break;
            }
        }

        if (bestLag === -1) return -1;

        let T0 = bestLag;
        // Parabolic interpolation for sub-sample accuracy
        if (T0 > 0 && T0 < maxLag) {
            const y1 = diff[T0 - 1];
            const y2 = diff[T0];
            const y3 = diff[T0 + 1];
            const a = (y1 + y3 - 2 * y2) / 2;
            const b = (y3 - y1) / 2;
            if (a) T0 = T0 - b / (2 * a);
        }

        return sampleRate / T0;
    }

    static referencePitch = 440;

    // Map frequency to note components
    static getNoteFromFrequency(frequency) {
        if (frequency <= 0 || isNaN(frequency)) return null;
        const NOTES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        // Standard formula: n = 12 * log2(f / ref)
        const n = 12 * Math.log2(frequency / AudioProcessor.referencePitch);
        const roundN = Math.round(n);
        const noteIndex = (roundN + 69) % 12;
        const octave = Math.floor((roundN + 69) / 12) - 1;
        const cents = 100 * (n - roundN);

        return {
            name: NOTES[noteIndex < 0 ? noteIndex + 12 : noteIndex],
            octave,
            cents,
            frequency: parseFloat(frequency.toFixed(2))
        };
    }
    // Targeted polyphonic detection for guitar strings
    getPolyNotes(guitarTargets) {
        if (!this.dataArray) return [];
        const sampleRate = this.audioContext.sampleRate;
        const binCount = this.analyser.frequencyBinCount;
        const fftSize = this.analyser.fftSize;

        // We need frequency data for polyphonic isolation
        const freqData = new Float32Array(binCount);
        this.analyser.getFloatFrequencyData(freqData);

        const detected = [];

        guitarTargets.forEach(target => {
            const targetFrequency = target.targetFreq || target.freq;
            // Search window (+/- 1.5 semitones to avoid overlap/harmonic interference)
            const lowFreq = targetFrequency * Math.pow(2, -1.5 / 12);
            const highFreq = targetFrequency * Math.pow(2, 1.5 / 12);

            let maxMag = -Infinity;
            let bestBin = -1;

            const lowBin = Math.floor(lowFreq * fftSize / sampleRate);
            const highBin = Math.ceil(highFreq * fftSize / sampleRate);

            // Bounds check
            if (lowBin < 0 || highBin >= binCount) return;

            for (let i = lowBin; i <= highBin; i++) {
                if (freqData[i] > maxMag) {
                    maxMag = freqData[i];
                    bestBin = i;
                }
            }

            // Strum sensitivity threshold (-95 dB to ensure we pick up weaker audio)
            if (maxMag > -95) {
                // Parabolic interpolation for sub-bin accuracy
                const y1 = freqData[bestBin - 1] || freqData[bestBin];
                const y2 = freqData[bestBin];
                const y3 = freqData[bestBin + 1] || freqData[bestBin];

                let refinedFreq = bestBin * sampleRate / fftSize;
                if (y1 !== y2 || y2 !== y3) {
                    const p = 0.5 * (y1 - y3) / (y1 - 2 * y2 + y3);
                    refinedFreq = (bestBin + p) * sampleRate / fftSize;
                }

                const note = AudioProcessor.getNoteFromFrequency(refinedFreq);
                detected.push({ ...note, magnitude: maxMag, targetFreq: targetFrequency });
            }
        });

        return detected;
    }

    // Monophonic detection for the simple view
    getMonoNote() {
        if (!this.dataArray) return null;
        const sampleRate = this.audioContext.sampleRate;
        const monoFreq = AudioProcessor.autoCorrelate(this.dataArray, sampleRate);
        if (monoFreq !== -1 && monoFreq < 1200) {
            return AudioProcessor.getNoteFromFrequency(monoFreq);
        }

        // Fallback to FFT if Autocorrelation fails (e.g. noise or transients)
        const binCount = this.analyser.frequencyBinCount;
        const fftSize = this.analyser.fftSize;
        const freqData = new Float32Array(binCount);
        this.analyser.getFloatFrequencyData(freqData);

        let maxMag = -Infinity;
        let bestBin = -1;
        for (let i = 2; i < binCount; i++) { // Ignore extreme lows
            if (freqData[i] > maxMag) {
                maxMag = freqData[i];
                bestBin = i;
            }
        }

        if (maxMag > -90 && bestBin > 0) {
            const y1 = freqData[bestBin - 1] || freqData[bestBin];
            const y2 = freqData[bestBin];
            const y3 = freqData[bestBin + 1] || freqData[bestBin];
            let refinedFreq = bestBin * sampleRate / fftSize;
            if (y1 !== y2 || y2 !== y3) {
                const p = 0.5 * (y1 - y3) / (y1 - 2 * y2 + y3);
                refinedFreq = (bestBin + p) * sampleRate / fftSize;
            }
            return AudioProcessor.getNoteFromFrequency(refinedFreq);
        }

        return null;
    }

    // Expose byte frequency data for visualizer
    getByteFrequencyData(array) {
        if (this.analyser && this.isInitialized) {
            this.analyser.getByteFrequencyData(array);
        }
    }
}



const processor = new AudioProcessor();
const startBtn = document.getElementById('start-audio');
const initialOverlay = document.getElementById('initial-overlay');
const navItems = document.querySelectorAll('.nav-item');
const views = document.querySelectorAll('.view');

// Analyzer State
let analyzerEnabled = false;
const analyzerBtn = document.getElementById('analyzer-toggle-btn');
const analyzerCanvas = document.getElementById('analyzer-canvas');
let analyzerCtx = null;

if (analyzerCanvas) {
    analyzerCtx = analyzerCanvas.getContext('2d');
    const resizeAnalyzer = () => {
        analyzerCanvas.width = window.innerWidth * window.devicePixelRatio;
        analyzerCanvas.height = window.innerHeight * window.devicePixelRatio;
    };
    window.addEventListener('resize', resizeAnalyzer);
    resizeAnalyzer();
}

if (analyzerBtn) {
    analyzerBtn.addEventListener('click', () => {
        analyzerEnabled = !analyzerEnabled;
        if (analyzerEnabled) {
            analyzerBtn.classList.add('active');
            analyzerCanvas.classList.add('active');
        } else {
            analyzerBtn.classList.remove('active');
            analyzerCanvas.classList.remove('active');
            if (analyzerCtx) {
                analyzerCtx.clearRect(0, 0, analyzerCanvas.width, analyzerCanvas.height);
            }
        }
    });
}

// Tuning definitions
const TUNINGS = {
    standard: [
        { id: 6, note: 'E', octave: 2, midi: 40 },
        { id: 5, note: 'A', octave: 2, midi: 45 },
        { id: 4, note: 'D', octave: 3, midi: 50 },
        { id: 3, note: 'G', octave: 3, midi: 55 },
        { id: 2, note: 'B', octave: 3, midi: 59 },
        { id: 1, note: 'e', octave: 4, midi: 64 }
    ],
    drop_d: [
        { id: 6, note: 'D', octave: 2, midi: 38 },
        { id: 5, note: 'A', octave: 2, midi: 45 },
        { id: 4, note: 'D', octave: 3, midi: 50 },
        { id: 3, note: 'G', octave: 3, midi: 55 },
        { id: 2, note: 'B', octave: 3, midi: 59 },
        { id: 1, note: 'e', octave: 4, midi: 64 }
    ],
    open_g: [
        { id: 6, note: 'D', octave: 2, midi: 38 },
        { id: 5, note: 'G', octave: 2, midi: 43 },
        { id: 4, note: 'D', octave: 3, midi: 50 },
        { id: 3, note: 'G', octave: 3, midi: 55 },
        { id: 2, note: 'B', octave: 3, midi: 59 },
        { id: 1, note: 'd', octave: 4, midi: 62 }
    ],
    eb_standard: [
        { id: 6, note: 'D#', octave: 2, midi: 39 },
        { id: 5, note: 'G#', octave: 2, midi: 44 },
        { id: 4, note: 'C#', octave: 3, midi: 49 },
        { id: 3, note: 'F#', octave: 3, midi: 54 },
        { id: 2, note: 'A#', octave: 3, midi: 58 },
        { id: 1, note: 'd#', octave: 4, midi: 63 }
    ],
    open_esus2: [
        { id: 6, note: 'E', octave: 2, midi: 40 },
        { id: 5, note: 'B', octave: 2, midi: 47 },
        { id: 4, note: 'E', octave: 3, midi: 52 },
        { id: 3, note: 'F#', octave: 3, midi: 54 },
        { id: 2, note: 'B', octave: 3, midi: 59 },
        { id: 1, note: 'e', octave: 4, midi: 64 }
    ],
    dadgad: [
        { id: 6, note: 'D', octave: 2, midi: 38 },
        { id: 5, note: 'A', octave: 2, midi: 45 },
        { id: 4, note: 'D', octave: 3, midi: 50 },
        { id: 3, note: 'G', octave: 3, midi: 55 },
        { id: 2, note: 'A', octave: 3, midi: 57 },
        { id: 1, note: 'd', octave: 4, midi: 62 }
    ],
    rain_song: [
        { id: 6, note: 'D', octave: 2, midi: 38 },
        { id: 5, note: 'G', octave: 2, midi: 43 },
        { id: 4, note: 'C', octave: 3, midi: 48 },
        { id: 3, note: 'G', octave: 3, midi: 55 },
        { id: 2, note: 'C', octave: 4, midi: 60 },
        { id: 1, note: 'd', octave: 4, midi: 62 }
    ],
    custom: [] // Populated dynamically
};

let currentTuningKey = 'standard';
let referencePitch = 440;
let GUITAR_STRINGS = [];

function updateGuitarStrings() {
    GUITAR_STRINGS = TUNINGS[currentTuningKey].map(string => ({
        ...string,
        targetFreq: referencePitch * Math.pow(2, (string.midi - 69) / 12)
    }));
    AudioProcessor.referencePitch = referencePitch;
}

updateGuitarStrings(); // Initialize the active targets array

// Settings Events
const customTuningInput = document.getElementById('custom-tuning-input');
const customTuningText = document.getElementById('custom-tuning-text');
const applyCustomBtn = document.getElementById('apply-custom-tuning');

function parseCustomNotes(text) {
    const notesStr = text.split(',').map(s => s.trim()).filter(s => s);
    const parsed = [];
    const NOTES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    notesStr.forEach((noteStr, index) => {
        const match = noteStr.match(/^([a-gA-G]#?)([0-9])$/);
        if (match) {
            let noteName = match[1].toUpperCase();
            if (noteName.includes('B#')) noteName = 'C';
            if (noteName.includes('E#')) noteName = 'F';
            const octave = parseInt(match[2], 10);
            let noteIdx = NOTES.indexOf(noteName);
            if (noteIdx !== -1) {
                const midi = (octave + 1) * 12 + noteIdx;
                parsed.push({
                    id: notesStr.length - index,
                    note: match[1],
                    octave: octave,
                    midi: midi
                });
            }
        }
    });
    return parsed;
}

if (applyCustomBtn) {
    applyCustomBtn.addEventListener('click', () => {
        const parsed = parseCustomNotes(customTuningText.value);
        if (parsed.length > 0) {
            TUNINGS.custom = parsed;
            updateGuitarStrings();
            reinitPolyTuner();
            alert(`Applied custom tuning: ${parsed.map(p => p.note + p.octave).join(', ')}`);
        } else {
            alert("Invalid format! Please use format like: E4, B3, G3, D3, A2, E2");
        }
    });
}

document.querySelectorAll('input[name="tuning"]').forEach(radio => {
    radio.addEventListener('change', (e) => {
        currentTuningKey = e.target.value;
        if (currentTuningKey === 'custom') {
            customTuningInput.style.display = 'flex';
            TUNINGS.custom = parseCustomNotes(customTuningText.value);
        } else {
            customTuningInput.style.display = 'none';
        }
        updateGuitarStrings();
        reinitPolyTuner();
    });
});

const pitchSlider = document.getElementById('pitch-slider');
const pitchVal = document.getElementById('pitch-val');

function updateSliderBackground() {
    if (!pitchSlider) return;
    const val = (pitchSlider.value - pitchSlider.min) / (pitchSlider.max - pitchSlider.min) * 100;
    pitchSlider.style.background = `linear-gradient(to right, #00ff88 0%, #00ff88 ${val}%, rgba(255, 255, 255, 0.1) ${val}%, rgba(255, 255, 255, 0.1) 100%)`;
}

if (pitchSlider && pitchVal) {
    pitchSlider.addEventListener('input', (e) => {
        referencePitch = parseInt(e.target.value, 10);
        pitchVal.textContent = `${referencePitch} Hz`;
        updateSliderBackground();
        updateGuitarStrings();
        reinitPolyTuner();
    });

    // Set initial custom background
    updateSliderBackground();
}

class TuningCard {
    constructor(container, stringInfo = null) {
        this.container = container;
        this.stringInfo = stringInfo;
        this.element = this.createCard();
        this.container.appendChild(this.element);
        this.canvas = this.element.querySelector('.oscilloscope-canvas');
        this.ctx = this.canvas.getContext('2d');

        this.history = new Array(100).fill(0); // Store last 100 cents measurements
        this.isActuallyDetected = false;

        this.resize();
        window.addEventListener('resize', () => this.resize());
    }

    createCard() {
        const card = document.createElement('div');
        card.className = 'tuning-card';
        const label = this.stringInfo ? `${this.stringInfo.id} - ${this.stringInfo.note}` : '1 - E';

        card.innerHTML = `
      <div class="card-header">
        <div class="string-info">${label}</div>
        <div class="measurement-info">
          <span class="cents-display">+0.0</span>
          <span class="cents-label">Cents</span>
          <span class="freq-display">0.0 Hz</span>
        </div>
      </div>
      <div class="scale-container">
        <div class="scale-markers">
          <span>-50</span>
          <span>-30</span>
          <span>-20</span>
          <span>-10</span>
          <span>0</span>
          <span>+10</span>
          <span>+20</span>
          <span>+30</span>
          <span>+50</span>
        </div>
        <div class="scale-line"></div>
        <canvas class="oscilloscope-canvas"></canvas>
      </div>
    `;
        return card;
    }

    resize() {
        this.canvas.width = this.canvas.clientWidth * window.devicePixelRatio;
        this.canvas.height = this.canvas.clientHeight * window.devicePixelRatio;
    }

    update(data) {
        const { cents, frequency, isDetected, name, octave } = data;
        const centsElem = this.element.querySelector('.cents-display');
        const freqElem = this.element.querySelector('.freq-display');
        const noteElem = this.element.querySelector('.string-info');

        this.isActuallyDetected = isDetected;

        if (isDetected) {
            const freqValue = typeof frequency === 'number' ? frequency : parseFloat(frequency);
            centsElem.textContent = (cents >= 0 ? '+' : '') + cents.toFixed(1);
            freqElem.textContent = freqValue.toFixed(1) + ' Hz';

            // Update label based on the actual detected note, even in poly tuner
            if (!this.stringInfo) {
                noteElem.textContent = `${name}${octave}`;
            } else {
                noteElem.textContent = `${this.stringInfo.id} - ${name}${octave}`;
            }

            // Push to history
            this.history.push(cents);
            this.history.shift();

            if (Math.abs(cents) < 5) {
                this.element.classList.add('in-tune');
            } else {
                this.element.classList.remove('in-tune');
            }
        } else {
            centsElem.textContent = '+0.0';
            freqElem.textContent = '0.0 Hz';
            this.element.classList.remove('in-tune');

            if (!this.stringInfo) {
                noteElem.textContent = '---';
            } else {
                noteElem.textContent = `${this.stringInfo.id} - ${this.stringInfo.note}`;
            }

            // Push 0 or stay static when not detected? 
            // In a horizontal tracker, we usually push the last value or 0 or just stop.
            // Let's push something that shows "not listening"
            this.history.push(null);
            this.history.shift();
        }

        this.drawHistory();
    }

    drawHistory() {
        const w = this.canvas.width;
        const h = this.canvas.height;
        this.ctx.clearRect(0, 0, w, h);

        const step = h / (this.history.length - 1);
        this.ctx.beginPath();
        this.ctx.lineWidth = 3;
        this.ctx.strokeStyle = '#ffffff';
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';

        // We want to color each segment dynamically.
        // Red when far away (> 10 cents), interpolating to Green when close (0 cents).
        let first = true;
        for (let i = 0; i < this.history.length; i++) {
            const cents = this.history[i];
            if (cents === null) {
                first = true;
                continue;
            }

            // Map cents (-50 to +50) to canvas width (X-axis)
            const x = w / 2 + (cents / 50) * (w * 0.4);
            const y = h - i * step;

            if (first) {
                this.ctx.beginPath();
                this.ctx.moveTo(x, y);
                first = false;
            } else {
                // Color mapping: 
                // Math.abs(cents): 0 -> #00ff88 (Green)
                // Math.abs(cents): 20+ -> #ff4466 (Red)
                const errorRatio = Math.min(1.0, Math.abs(cents) / 20); // 0 = perfect, 1 = red
                const r = Math.round(0 + errorRatio * 255);
                const g = Math.round(255 - errorRatio * 187); // 255 to 68
                const b = Math.round(136 - errorRatio * 34);  // 136 to 102
                const strokeColor = `rgba(${r}, ${g}, ${b}, ${1.0 - (i / this.history.length) * 0.8})`;

                this.ctx.lineTo(x, y);
                this.ctx.strokeStyle = strokeColor;
                this.ctx.shadowBlur = errorRatio < 0.2 ? 10 : 0;
                this.ctx.shadowColor = 'rgba(0, 255, 136, 0.5)';
                this.ctx.stroke();

                // Start next segment
                this.ctx.beginPath();
                this.ctx.moveTo(x, y);
            }
        }
    }
}

let simpleCard = null;
let polyCards = [];

function initTuner() {
    const simpleContainer = document.getElementById('simple-tuner-container');
    simpleCard = new TuningCard(simpleContainer);
    reinitPolyTuner();
}

function reinitPolyTuner() {
    const polyGrid = document.getElementById('poly-tuner-grid');
    if (polyGrid) {
        polyGrid.innerHTML = '';
        polyCards = GUITAR_STRINGS.map(string => new TuningCard(polyGrid, string));

        // Re-calculate layout if poly-view happens to be active
        const polyView = document.getElementById('poly-view');
        if (polyView && polyView.classList.contains('active')) {
            polyCards.forEach(card => card.resize());
        }
    }
}

// Navigation handling
navItems.forEach(item => {
    item.addEventListener('click', () => {
        const targetViewId = item.getAttribute('data-view');

        navItems.forEach(nb => nb.classList.remove('active'));
        item.classList.add('active');

        views.forEach(view => {
            view.classList.remove('active');
            if (view.id === targetViewId) {
                view.classList.add('active');
                // Trigger resize for all cards in the new view
                if (targetViewId === 'simple-view' && simpleCard) {
                    simpleCard.resize();
                } else if (targetViewId === 'poly-view') {
                    polyCards.forEach(card => card.resize());
                }
            }
        });
    });
});

startBtn.addEventListener('click', async () => {
    const success = await processor.initialize();
    if (success) {
        initialOverlay.style.display = 'none';
        initTuner();
        animate();
    } else {
        alert('Could not access microphone. Please check permissions.');
    }
});

function animate() {
    // Ensure context is running (browsers may suspend it)
    if (processor.audioContext && processor.audioContext.state === 'suspended') {
        processor.audioContext.resume();
    }

    const simpleView = document.getElementById('simple-view');

    if (simpleView && simpleView.classList.contains('active')) {
        // Only run Monophonic processing
        const monoNote = processor.getMonoNote() || { cents: 0, frequency: 0, isDetected: false };
        if (simpleCard) simpleCard.update({ ...monoNote, isDetected: !!monoNote.name });
    } else if (polyCards.length > 0) {
        // Only run Polyphonic processing passing dynamic array
        const detected = processor.getPolyNotes(GUITAR_STRINGS);
        // Update all 6 strings in poly view
        polyCards.forEach((card, index) => {
            const stringInfo = GUITAR_STRINGS[index];
            const match = detected.find(n => {
                // Approximate match for the string (within 2 semitones)
                const freq = typeof n.frequency === 'number' ? n.frequency : parseFloat(n.frequency);
                const freqDiff = Math.abs(1200 * Math.log2(freq / stringInfo.targetFreq));
                return freqDiff < 200;
            });

            if (match) {
                // For poly mode, calculate cents relative to the TARGET frequency of the string
                const freq = typeof match.frequency === 'number' ? match.frequency : parseFloat(match.frequency);
                const relativeCents = 1200 * Math.log2(freq / stringInfo.targetFreq);
                card.update({ ...match, cents: relativeCents, isDetected: true });
            } else {
                card.update({ cents: 0, frequency: stringInfo.targetFreq, isDetected: false });
            }
        });
    }

    // Draw Frequency Analyzer if enabled
    if (analyzerEnabled && analyzerCtx) {
        const w = analyzerCanvas.width;
        const h = analyzerCanvas.height;
        const binCount = processor.analyser.frequencyBinCount;
        const byteData = new Uint8Array(binCount);
        processor.getByteFrequencyData(byteData);

        analyzerCtx.clearRect(0, 0, w, h);

        // Draw a smooth wave at the bottom, centered horizontally
        // Display first 1024 bins which covers up to ~2.7kHz at 44.1kHz (perfect for guitar)
        const displayBins = Math.min(1024, binCount);

        // We will draw from the center outwards symmetrically
        const center = w / 2;
        const step = center / displayBins;

        analyzerCtx.beginPath();
        analyzerCtx.moveTo(w, h); // Start at bottom right
        analyzerCtx.lineTo(0, h); // Line to bottom left

        // Left side (mirrored)
        for (let i = displayBins - 1; i >= 0; i--) {
            const value = byteData[i];
            const percent = value / 255;
            const height = percent * h * 0.4; // Max height is 40% of screen
            const x = center - (i * step);
            analyzerCtx.lineTo(x, h - height);
        }

        // Right side (normal)
        for (let i = 0; i < displayBins; i++) {
            const value = byteData[i];
            const percent = value / 255;
            const height = percent * h * 0.4;
            const x = center + (i * step);
            analyzerCtx.lineTo(x, h - height);
        }

        analyzerCtx.lineTo(w, h);
        analyzerCtx.closePath();

        const gradient = analyzerCtx.createLinearGradient(0, h, 0, h * 0.6);
        gradient.addColorStop(0, 'rgba(0, 255, 136, 0.5)');
        gradient.addColorStop(1, 'rgba(0, 255, 136, 0.0)');

        analyzerCtx.fillStyle = gradient;
        analyzerCtx.fill();

        analyzerCtx.lineWidth = 2;
        analyzerCtx.strokeStyle = 'rgba(0, 255, 136, 0.8)';
        analyzerCtx.stroke();
    }

    requestAnimationFrame(animate);
}

</script>
</body>

</html>